Grok: to understand something fully and intuitively.

Grokking: the process of reaching deep, intuitive understanding.

----------------------------------------------------------------------------------
# generalization problem ---> more sophcisitacated architecture + MORE DATA


DATA --> generalization

(amount of training data)



100%


20% --> train ;80% val ; result
9409

30% --> train ;80% val ; result

----------------------------------

a  ◦ a = a
a  ◦ b = d
.....
b  ◦ a = c
e  ◦ a = b
c  ◦ d = b

20 equations ==> input data

5 equation ==> test(benchmark for the model)




----------------------------------
A binary operation is just a rule that takes two inputs and produces one output:

    a∘b=c


Addition
    symbols = {0, 1, 2, 3, 4}

        a∘b = (a+b)mod5

        2 ◦ 3 = 0
        4 ◦ 4 = 3
        1 ◦ 0 = 1

Composition of permutations

    symbols =  {1,2,3}

        a = (1→2, 2→3, 3→1)
        b = (1→1, 2→3, 3→2)
        c = (1→3, 2→1, 3→2)


    a∘b=apply b first, then a

        a ◦ b = c
        b ◦ a = d 

----------------------------------------------------------------------------------

S = {1,2,3,4,5,.......,n}

x,y member of S; operation; x+y member of S (Field)


R 
Z (add)

N(subtraction ) not a field

8,9 ==> 9-8 = 1 
8,9 ==> 8-9 = -1 not a membmer of N 



Sp = {1,....,p}
x+y = (x+y ) % p

Addition
3+5 = 8 not member
3+5 = 8 mode 5 =3




S5 is the symmetric group on 5 elements
    {1,2,3,4,5}

closed binary operation; mod something (for a prime number p = 97)

 **** x ◦ y = x + y (mod p) for 0 ≤ x, y < p
x ◦ y = x − y (mod p) for 0 ≤ x, y < p
x ◦ y = x/y (mod p) for 0 ≤ x < p, 0 < y < p
**** x ◦ y = [x/y (mod p) if y is odd, otherwise x − y (mod p)] for 0 ≤ x, y < p
x ◦ y = x2 + y2 (mod p) for 0 ≤ x, y < p
x ◦ y = x2 + xy + y2 (mod p) for 0 ≤ x, y < p
x ◦ y = x2 + xy + y2 + x (mod p) for 0 ≤ x, y < p
x ◦ y = x3 + xy (mod p) for 0 ≤ x, y < p
**** x ◦ y = x3 + xy2 + y (mod p) for 0 ≤ x, y < p
x ◦ y = x · y for x, y ∈ S5
x ◦ y = x · y · x−1 for x, y ∈ S5
x ◦ y = x · y · x for x, y ∈ S5


----------------------------------------------------------------------------------

x ◦ y = x + y (mod p) for 0 ≤ x, y < p

p =8

binary operation table

  1 2 3 4 5 6 7 8
1 2 3 4 5 6 7 0 1
2 3 4 5 6 7 0 1 2
3 4 5 6 7 0 1 2 3
4 5 6 7 0 1 2 3 4
5 6 7 0 1 2 3 4 5
6 7 0 1 2 3 4 5 6
7
8


8x8 = 49

1st : 1◦1 = 2
2nd : 1◦2 = 3

20th; 3◦4 =7
21th 3◦5=0


49 ; 40 train ; 9 val


------------------------
a=7 ,b ==6 > output 5

a==> vector,b==>vecotr ==> vector ==> 5


-----------------------------

1
    x+y mod prime ===> aka . r^q 
    x*y mod prime ===> aka . r^q

    + *
    - /


2
symmetric
    x + y = y+x 
    x ∗ y = y * x
    x2 + y2 = y2+x2



    counterparts

    x-y != y-x

3
x3 + xy2 + y

10^7 ==> 10^20 generalization or not
the operation too hard 


 x ◦ y = [x/y (mod p) if y is odd, otherwise x − y (mod p)] for 0 ≤ x, y < p
----------------------
12345

25


1,2,3,4,5,6,7

7x7=49data

0.5% ~= 25data











---------------------------------------------
from sklearn.manifold import TSNE

p=5

W = net.to_vocab.weight.detach().cpu().float().numpy()

W = W / (np.linalg.norm(W, axis=1, keepdims=True) + 1e-12)

tsne = TSNE(
    n_components=2,
    perplexity=30,
    init="pca",
    learning_rate="auto",
    random_state=42,
)
Z = tsne.fit_transform(W)  # [p, 2]

x, y = Z[:, 0], Z[:, 1]
colors = (np.arange(p) % 8)

plt.figure(figsize=(8, 7))
sc = plt.scatter(x, y, c=colors, s=35)
plt.axis("off")

for i in range(p):
    j = (i + 8) % p
    plt.plot([x[i], x[j]], [y[i], y[j]], linewidth=0.6, alpha=0.5)

for i in range(p):
    plt.text(x[i], y[i], str(i), fontsize=8, ha="center", va="center")

plt.title(f"t-SNE of output weights (V={p}), lines: +{8} mod {p}, colors: mod 8")
plt.show()

Z



0.5 ==> x/y ; 6-7k
0.3 ==> x/y ; 36k
0.5 ==> x+y ; 1k
0.3 ==> x+y ; 3k