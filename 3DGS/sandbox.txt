

Anisotropic

    Direction-dependent. It means the 3D blob doesn't have to be a perfect sphere

    Numeric:
        Isotropic (Sphere): Scale [1, 1, 1]. You would need 10 of these stacked to cover a long wire.
        Anisotropic (Splat): Scale [10, 0.1, 0.1]. You only need 1 of these to cover the same wire.

    fewer blobs, saving memory ("compactly")

--------------------------------------------------------------------------------------

Rasterization
    - The process of converting vector primitives (in this case, 3D Gaussians) directly into pixels on your screen.

Rasterizer
    - The specific software engine (CUDA kernel in this paper) that executes this projection and blending.

NeRF (Ray Marching): 
    You shoot a ray per pixel, sample hundreds of points along the ray, query an MLP, and integrate
    !!!!! Expensive

3DGS (Rasterization): 
    You project the 3D Gaussians onto the 2D screen (splatting)
    sort them by depth
    blend them (alpha compositing) to get pixel colors.
    feed-forward geometry processing, much closer to traditional triangle rendering 


--------------------------------------------------------------------------------------
The input consists of three things usually generated by COLMAP.

    1 A Set of Images
        Standard RGB photos of a static object/scene.
        img_001.jpg - img_100.jpg

    2 Camera Parameters (Calibration matrices)
        Intrinsics :
                      
                      [1100.5   0   960] 
                      [0    1100.5  540]
                      [0       0      1]

        Extrinsics (Rotation R and Translation T):
            
                      [0.86    -0.5    0   1.5] 
                      [0.5      0.86   0  -0.2] 
                      [0        0      1     3] 
                      [0        0      0     1] 


    3 Sparse Point Cloud 
        COLMAP matches features across images (SIFT) to calculate the cameras; 
        the resulting 3D points are the "sparse cloud."
        This is used to initalize the centers (means) of the 3D Gaussians.
            Point 0:    pos: [1.02, -0.55, 3.20], color: [255, 128, 0]
            Point 1:    pos: [1.05, -0.54, 3.21], color: [255, 130, 10]

--------------------------------------------------------------------------------------
Covariance vs. Correlation


    Covariance

        Definition: Measures the direction of the relationship.

            Positive: X goes up, Y goes up.
            Negative: X goes up, Y goes down.


    Correlation

        Definition: The normalized version of covariance.
        Formula: Correlation= â€‹Covarianceâ€‹/Ïƒxâ€‹.Ïƒy

            1: Perfect positive match.
            0: No relationship (random).
            âˆ’1: Perfect inverse match.

Cov(X,Y) =  âˆ‘(xiâ€‹âˆ’xË‰)(yiâ€‹âˆ’yË‰â€‹)â€‹ / N

--------------------------------------------------------------------------------------

Î£ =  [ â€‹Var(X) Cov(Y,X) Cov(Z,X) 
       â€‹Cov(X,Y) Var(Y) Cov(Z,Y)
       â€‹Cov(X,Z) Cov(Y,Z) Var(Z)â€‹â€‹ ]


Sphere (Isotropic)
Î£=  [1 0 0
     0 1 0
     0 0 1]

    Diagonals are equal (1): Same width in X, Y, Z.
    Off-diagonals are 0: No tilting.

Pancake (Anisotropic)
Î£=  [5 0  0
     0 10 0
     0 0 .1]
    
    Diagonals: High variance in X and Y (5), tiny in Z (0.1).

The Tilted Cigar (Correlated)
Î£=  [5 3  0
     3 2  0
     0 0 .1]

    Diagonal: Stretched more in X than Y than z
    Off-Diagonal (3): High covariance between X and Y.
--------------------------------------------------------------------------------------
G(x)= np.exp( -1/2 xT Î£-1(x) )

This is the math formula that calculates the Opacity (fog density) at a specific point x.

    x: The offset vector
        - How far is your point from the center
            center = [1,1,1] and you are at [2,0,0], then x = [1,-1,-1]


    Î£âˆ’1 (Inverse Covariance): The "Precision" matrix. It is the opposite of the Spread.
        - Big Spread (High Variance) â†’ Tiny Inverse
        - Small Spread (Low Variance) â†’ Huge Inverse

    (x)T Î£âˆ’1(x):  Weighted Distance

e^ -1/2â€‹(â€¦): This converts that distance into a 0 to 1 scale.

        Distance 0 â†’ Density 1
        Distance Huge â†’ Density 0

--------------------------------------------------------------------------------------

Splat:
    Î£â€² = ð½ð‘Š Î£ ð‘Šð‘‡ð½ð‘‡ 


The Dimensions:

    Î£â€² (2D Covariance): [2Ã—2]. The Flat Splat.
    J (Jacobian Projector): [2Ã—3]. Converts 3D (X, Y, Z) to 2D (u, v).
    Î£ (3D Covariance): [3Ã—3]. The 3D Rugby Ball.
    W (Viewing Rotation): [3Ã—3]. Rotates 3D to 3D.




W = Rotation part of the Extrinsics(External calibration matrix)

Variance is roughly "Standard Deviation squared" It is measured in Meters Squared (m2).
    NewPosition = 3 Ã— OldPosition
    NewVariance = 3 Ã— OldVariance Ã— 3
    
Î£â€² 2D Covariance Matrix


    Round Dot: 
        [ 5 0
          â€‹0 5 â€‹] 
        (5px wide, 5px tall, no tilt).

    Long Streak:
        [ 50 0
          â€‹0  5 â€‹] 
        (50px wide, 2px tall).

    Tilted Streak: 
        [ 20 15
          â€‹15 20â€‹]  
        (Stretched diagonally).

    [ a b
     â€‹ b câ€‹ ]

    a & c (Diagonals): How wide (Pixels in X) and tall (Pixels in Y) the oval is.
    b (Off-Diagonal): How tilted the oval is

Jacobian

Imagine a function F that takes 3 Inputs (x,y,z) and produces 2 Outputs (u,v).

    Input Vector: x=[x,y,z]
    Function:
        u=f1â€‹(x,y,z)
        v=f2â€‹(x,y,z)


The Jacobian J will be a matrix of Partial Derivatives.

    Rows: One row for each Output (u,v).
    Columns: One column for each Input (x,y,z)
    Dimensions: 2Ã—3
    
    J=[ 
        âˆ‚x/âˆ‚u â€‹â€‹â€‹âˆ‚y/âˆ‚uâ€‹ â€‹â€‹âˆ‚z/âˆ‚uâ€‹ 
        âˆ‚x/âˆ‚v âˆ‚y/âˆ‚v âˆ‚z/âˆ‚vâ€‹â€‹  ]

Î£â€²

    Î£ cameraâ€‹ = 
        [ â€‹Spread X  Tilt YX  Tilt ZXâ€‹
          Tilt XY  Spread Y  Tilt ZY
          â€‹Tilt XZ  Tilt YZ  Spread Zâ€‹â€‹ ]

--------------------------------------------------------------------------------------


Î£ = ð‘….ð‘† ð‘†ð‘‡.ð‘…T

Storing format:
    s = [sx,sy,sx]
    q = [ w , x , y , z] ==> q = [cos(Î¸/2)â€‹â€‹ , sin(Î¸/2) , sin(Î¸/2) ,sin(Î¸/2)]

s = [sxâ€‹ , sy â€‹, szâ€‹]
Output:
    S=â€‹[ sxâ€‹ 0 0
        â€‹0 sy â€‹0
        â€‹0 0 sz ]
    
qnormâ€‹ = q/ sqrt(x2+y2+z2+w2â€‹qâ€‹â€‹â€‹)


R= [
    â€‹1âˆ’2(y2+z2) 2(xy+wz) 2(xzâˆ’wy)â€‹
    2(xyâˆ’wz) 1âˆ’2(x2+z2) 2(yz+wx)â€‹
    2(xz+wy) 2(yzâˆ’wx) 1âˆ’2(x2+y2)â€‹â€‹
                                ]

--------------------------------------------------------------------------------------

Adaptive Control.

    Are any too big? Split them.

    Are any in high-error areas? Clone them.

    Are any invisible (Î±â‰ˆ0)? Delete them.


Positions (p) 
Covariance (Î£)
Opacity (Î±)



SH Coefficients (c): color

    Standard: RGB [1.0, 0, 0]

    SH Coefficients: Stores [Base=Red, Coeff_X=Positive].

        Look from Left: Base + Coeff â†’ Bright Red 
        Look from Right: Base - Coeff â†’ Dark Red 

Color =  âˆ‘ ( Coefficientiâ€‹ Ã— BasisFunctioniâ€‹(view) )

d=[dxâ€‹,dyâ€‹,dzâ€‹]=[0.6,0.8,0.0]

C0â€‹ (Ambient): 0.28209
C1â€‹ (Directional): 0.48860

Color = Ambient(f0â€‹â‹…C0â€‹)â€‹â€‹+ Top/Down: (f1â€‹â‹…C1â€‹â‹…dyâ€‹)â€‹+ Front/Back: (f2â€‹â‹…C1â€‹â‹…dzâ€‹)â€‹â€‹ + Left/Right: (f3â€‹â‹…C1â€‹â‹…dxâ€‹)â€‹â€‹